use crate::{Error, Result};
use helium_crypto::{PublicKey, Verify};
use helium_proto::services::{
    iot_config::{
        GatewayRegionParamsReqV1, LoadRegionReqV1, OrgCreateHeliumReqV1, OrgCreateRoamerReqV1,
        OrgDisableReqV1, OrgEnableReqV1, RouteCreateReqV1, RouteDeleteDevaddrRangesReqV1,
        RouteDeleteEuisReqV1, RouteDeleteReqV1, RouteGetDevaddrRangesReqV1, RouteGetEuisReqV1,
        RouteGetReqV1, RouteListReqV1, RouteStreamReqV1, RouteUpdateDevaddrRangesReqV1,
        RouteUpdateEuisReqV1, RouteUpdateReqV1,
    },
    poc_lora::{LoraBeaconReportReqV1, LoraWitnessReportReqV1},
};
use helium_proto::{
    services::poc_mobile::{CellHeartbeatReqV1, DataTransferSessionReqV1, SpeedtestReqV1},
    Message,
};

pub trait MsgVerify {
    fn verify(&self, verifier: &PublicKey) -> Result;
}

macro_rules! impl_msg_verify {
    ($msg_type:ty, $sig: ident) => {
        impl MsgVerify for $msg_type {
            fn verify(&self, verifier: &PublicKey) -> Result {
                let mut buf = vec![];
                let mut msg = self.clone();
                msg.$sig = vec![];
                msg.encode(&mut buf)?;
                verifier.verify(&buf, &self.$sig).map_err(Error::from)
            }
        }
    };
}

impl_msg_verify!(CellHeartbeatReqV1, signature);
impl_msg_verify!(SpeedtestReqV1, signature);
impl_msg_verify!(LoraBeaconReportReqV1, signature);
impl_msg_verify!(LoraWitnessReportReqV1, signature);
impl_msg_verify!(DataTransferSessionReqV1, signature);
impl_msg_verify!(OrgCreateHeliumReqV1, signature);
impl_msg_verify!(OrgCreateRoamerReqV1, signature);
impl_msg_verify!(OrgDisableReqV1, signature);
impl_msg_verify!(OrgEnableReqV1, signature);
impl_msg_verify!(RouteStreamReqV1, signature);
impl_msg_verify!(RouteListReqV1, signature);
impl_msg_verify!(RouteGetReqV1, signature);
impl_msg_verify!(RouteCreateReqV1, signature);
impl_msg_verify!(RouteUpdateReqV1, signature);
impl_msg_verify!(RouteDeleteReqV1, signature);
impl_msg_verify!(RouteGetEuisReqV1, signature);
impl_msg_verify!(RouteDeleteEuisReqV1, signature);
impl_msg_verify!(RouteUpdateEuisReqV1, signature);
impl_msg_verify!(RouteGetDevaddrRangesReqV1, signature);
impl_msg_verify!(RouteUpdateDevaddrRangesReqV1, signature);
impl_msg_verify!(RouteDeleteDevaddrRangesReqV1, signature);
impl_msg_verify!(GatewayRegionParamsReqV1, signature);
impl_msg_verify!(LoadRegionReqV1, signature);

#[cfg(test)]
mod test {
    use super::*;
    use base64::Engine;
    use helium_crypto::Sign;
    use rand::rngs::OsRng;
    use chrono::Utc;
    use std::str::FromStr;

    #[test]
    fn verify_heartbeat() {
        // Generated by FreedomFi
        const HEARTBEAT_MSG: &str = "CiEAucYd0JWglc+ffTbh+4s3wY6aWP4LTGxlbxyuMQJfviwSBmVub2RlYhjw0CYgq8mflwYp2Ls/3qtyREAxEHaKVYNMUsA4AUIBQUoZUDI3LVNDRTQyNTVXMjExMkNXNTAwMjUzNlJHMEUCIQDMXkTc49+zouvPTcf15ufutyQV04VoKW3ipqFkkIMxOgIgWAWJpo4MnNWzzzwMnE4OcY35XbsT34+K6ineoj50Szc=";
        let msg = CellHeartbeatReqV1::decode(
            base64::engine::general_purpose::STANDARD
                .decode(HEARTBEAT_MSG)
                .expect("base64 message")
                .as_ref(),
        )
        .expect("cell heartbeat");
        let public_key = PublicKey::from_bytes(&msg.pub_key).expect("public key");
        assert!(msg.verify(&public_key).is_ok());
    }

    #[test]
    fn verify_ed25519_heartbeat() {
        let key = helium_crypto::Keypair::generate(
            helium_crypto::KeyTag {
                network: helium_crypto::Network::MainNet,
                key_type: helium_crypto::KeyType::Ed25519,
            },
            &mut OsRng,
        );
        let pubkey = key.public_key();
        let b58_pubkey = pubkey.clone().to_string();
        println!("B58 Pubkey: {b58_pubkey}");

        let mut req = CellHeartbeatReqV1 {
            pub_key: pubkey.to_vec(),
            hotspot_type: "hotspot".to_string(),
            cell_id: 123,
            timestamp: Utc::now().timestamp() as u64,
            lat: 72.63,
            lon: 72.53,
            operation_mode: true,
            cbsd_category: "category".to_string(),
            cbsd_id: "id".to_string(),
            signature: vec![],
        };
        req.signature = key.sign(&req.encode_to_vec()).expect("signing req");
        let encoded = req.encode_to_vec();

        let decoded_pubkey = helium_crypto::PublicKey::from_str(&b58_pubkey).expect("decode public key");
        let decoded = CellHeartbeatReqV1::decode(encoded.as_slice()).expect("decode proto");
        assert!(decoded.verify(&decoded_pubkey).is_ok());
    }

    #[test]
    fn verify_speedtest() {
        // Generated by FreedomFi
        const SPEEDTEST_MSG: &str = "CiEAPGoan3wJ+7zNiR3cIvcPpVSIxpvNUcpa5i0W46TNduMSEEhMLTIxNTMtMDAwMTI2OTQYtoOhlwYgsN4CKKDnAjAxOkcwRQIhAI8gko+CSzGkC4JxIY0+g1HwL4/kii6HEktOmoCasEV3AiBJgKrRUAJFEOS8fJo4/v8DUehl0IbH3dPZFY4CXEOuKA==";
        let msg = SpeedtestReqV1::decode(
            base64::engine::general_purpose::STANDARD
                .decode(SPEEDTEST_MSG)
                .expect("base64 message")
                .as_ref(),
        )
        .expect("cell speedtest");
        let public_key = PublicKey::from_bytes(&msg.pub_key).expect("public key");
        assert!(msg.verify(&public_key).is_ok());
    }
    // TODO: Add tests for iot beacon and witness reports
}
